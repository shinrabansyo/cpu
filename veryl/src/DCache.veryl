proto package proc_proto {
    const addr_width: u32;
    const data_width: u32;

    type Addr;
    type Data;
}

proto package dcache_proto{
    const line_size: u32;
    const associativity: u32;
    const line_num: u32;

    const capacity: u32;
    const set_num: u32;

    const offset_width: u32;
    const index_width: u32;
    const tag_width: u32;

    const way_idx_width: u32;

    type Line;
    type Offset;
    type Index;
    type Tag;
    type WayIndex;

    function get_tag::<PROC_CONF: proc_proto>(addr: input PROC_CONF::Addr) -> Tag;
    function get_index::<PROC_CONF: proc_proto>(addr: input PROC_CONF::Addr) -> Index;
    function get_offset::<PROC_CONF: proc_proto>(addr: input PROC_CONF::Addr) -> Offset;
    function get_line_addr::<PROC_CONF: proc_proto>(addr: input PROC_CONF::Addr) -> PROC_CONF::Addr;
    function gen_addr::<PROC_CONF: proc_proto>( tag: input Tag, index: input Index, offset: input Offset) -> PROC_CONF::Addr; 
}

package proc_pkg for proc_proto{
    const addr_width: u32 = 32;
    const data_width: u32 = 32;

    type Addr = logic<addr_width>;
    type Data = logic<data_width>;
}

package dcache_pkg::<PROC_CONF: proc_proto> for dcache_proto{
    const line_size: u32 = 64;
    const associativity: u32 = 2;
    const line_num: u32 = 32;

    const capacity: u32 = line_size * line_num;
    const set_num: u32 = line_num / associativity;

    const offset_width: u32 = $clog2(line_size);
    const index_width: u32 = $clog2(set_num);
    const tag_width: u32 = PROC_CONF::addr_width - index_width - offset_width;

    const way_idx_width: u32 = $clog2(associativity);

    type Line = logic<8*line_size>;
    type Offset = logic<offset_width>;
    type Index = logic<index_width>;
    type Tag = logic<tag_width>;
    type WayIndex = logic<way_idx_width>;

    function get_tag(addr: input PROC_CONF::Addr) -> Tag {
        return addr[index_width + offset_width +: tag_width];
    }
    function get_index(addr: input PROC_CONF::Addr) -> Index {
        return addr[offset_width +: index_width];
    }
    function get_offset(addr: input PROC_CONF::Addr) -> Offset {
        return addr[0 +: offset_width];
    }
    function get_line_addr(addr: input PROC_CONF::Addr) -> PROC_CONF::Addr {
        return addr & {1'b1 repeat (PROC_CONF::addr_width - offset_width), 1'b0 repeat offset_width};
    }
    function gen_addr( tag: input Tag, index: input Index, offset: input Offset) -> PROC_CONF::Addr {
        return (tag << (index_width + offset_width)) | (index << offset_width) | offset;
    }
}

module SampleTop() {
    inst cache: DCache::<proc_pkg, dcache_pkg::<proc_pkg>, $std::axi4_pkg::<32, 4, 4, 0, 0, 0, 0, 0>>;
}

// 基本的なキャッシュ：ブロッキングで動く
// OoO なキャッシュ： ReqQ が埋まる＆依存関係のあるアクセスが来ない限りはノンブロッキングで動く
module DCache::<
    PROC_CONF: proc_proto,
    DCACHE_CONF: dcache_proto,
    AXI_CONF: $std::axi4_prototype,
> (
    i_clk: input clock,
    i_rst: input reset,

    // Core <-> Cache
    i_valid   : input  logic               ,
    o_ready   : output logic               ,
    i_addr    : input  PROC_CONF::Data    ,
    i_write_en: input  logic               ,
    i_byte_en : input  logic<PROC_CONF::data_width / 8>,
    i_data    : input  PROC_CONF::Data,
    o_data    : output PROC_CONF::Data,

    // Cache <-> RAM
    mem_if_master: modport $std::axi4_if::<AXI_CONF>::master,

) {
    // 各種定数
    const DataWidthInByte: u32 = PROC_CONF::data_width / 8;
    const WayIdxWidth:u32 = DCACHE_CONF::way_idx_width; // as DCACHE_CONF::way_idx_width は使えないので const で宣言

    // 接続
    inst mem_if: $std::axi4_if::<AXI_CONF>;
    connect mem_if.master <> mem_if_master;

    // 記憶領域
    inst tag_array: DCacheTagArray::<PROC_CONF, DCACHE_CONF>(
        i_clk,
        i_rst,

        i_ce: 1'b1,
        i_addr,

        // ヒット用信号
        o_hit: w_hit,
        o_hit_way: w_hit_way,

        // ミス用信号
        o_refill_way: w_refill_way,
        o_dirty: output logic,
        o_wb_line_addr: output PROC_CONF::Addr,
    );
    var m_tag_array : DCACHE_CONF::Tag     [DCACHE_CONF::associativity, DCACHE_CONF::set_num];
    var m_data_array: DCACHE_CONF::Line [DCACHE_CONF::associativity, DCACHE_CONF::set_num];
    var m_valid     : logic               [DCACHE_CONF::associativity, DCACHE_CONF::set_num];
    var m_dirty     : logic               [DCACHE_CONF::associativity, DCACHE_CONF::set_num];

    // 内部状態
    var r_saved_write_en : logic;
    var r_saved_wdata : logic;
    var r_saved_addr     : PROC_CONF::Data;
    var r_saved_byte_en  : logic<DataWidthInByte>;
    let w_addr_idx       : DCACHE_CONF::Index      = i_addr[DCACHE_CONF::offset_width+:DCACHE_CONF::index_width];
    let w_addr_line      : DCACHE_CONF::Offset       = i_addr[0+:DCACHE_CONF::offset_width];
    let w_saved_addr_line: DCACHE_CONF::Offset       = r_saved_addr[0+:DCACHE_CONF::offset_width];
    let w_saved_addr_tag : DCACHE_CONF::Tag        = r_saved_addr[DCACHE_CONF::offset_width + DCACHE_CONF::index_width+:DCACHE_CONF::tag_width];

    var r_read_tag  : logic<DCACHE_CONF::tag_width>     [DCACHE_CONF::associativity];
    var r_read_line : DCACHE_CONF::Line [DCACHE_CONF::associativity];
    var r_read_valid: logic               [DCACHE_CONF::associativity];
    var r_read_dirty: logic               [DCACHE_CONF::associativity];

    var w_need_two_line       : logic    ;
    var w_firsttime_read_bytes: logic<16>;
    var r_need_two_line       : logic    ;
    var r_firsttime_read_bytes: logic<16>;

    var w_hit     : logic           ;
    var w_hit_way : DCACHE_CONF::WayIndex ;
    var r_hit_way : DCACHE_CONF::WayIndex ;
    var r_hit_data: PROC_CONF::Data;

    var w_refill_way: DCACHE_CONF::WayIndex; // ミス時にリフィルする位置
    var w_need_wb: logic;
    var r_wb_line: DCACHE_CONF::Line; // WB するラインの一時保管場所
    var r_wb_line_addr: PROC_CONF::Data;
    var r_wb_burst_count: logic<8>;    // WBのバースト転送済みバイト数

    var r_mem_resp_count: logic<8>;     // memreq のバースト転送済みバイト数
    var r_mem_resp_line: DCACHE_CONF::Line;

    enum State {
        idle,
        tag_cmp,
        mem_req,
        replace,
    }

    var r_state: State;

    always_comb {
        w_firsttime_read_bytes = DataWidthInByte as 16;
        for i: u32 in 0..DataWidthInByte {
            if i + w_addr_line as 32 >= DCACHE_CONF::line_size {
                w_firsttime_read_bytes = i as 16;
                break;
            }
        }
        w_need_two_line = 0;
        for i: u32 in 0..DataWidthInByte {
            w_need_two_line |= i_byte_en[i] && (i + w_addr_line as 32) >= DCACHE_CONF::line_size;
        }
    }

    always_ff {
        if_reset {
            for way: u32 in 0..DCACHE_CONF::associativity {
                for idx: u32 in 0..DCACHE_CONF::set_num {
                    m_data_array[way][idx] = 0;
                }
                r_read_line[way]  = 0;
            }
            r_saved_write_en = 0;
            r_saved_wdata = 0;
            r_saved_addr           = 0;
            r_saved_byte_en        = 0;
            r_hit_data             = 0;
            r_need_two_line        = 0;
            r_firsttime_read_bytes = 0;
            r_mem_resp_count = 0;
            r_mem_resp_line = 0;
            r_state                = State::idle;
        } else {
            case (r_state) {
                State::idle: {
                    // 状態の更新
                    if i_valid {
                        r_state = State::tag_cmp;
                    }

                    // 内部状態の更新
                    if i_valid {
                        // TA/DA の並列読み出し
                        for way: u32 in 0..DCACHE_CONF::associativity {
                            r_read_line[way]  = m_data_array[way][w_addr_idx];
                        }
                        r_saved_write_en = i_write_en;
                        r_saved_wdata = i_data;
                        r_saved_addr    = i_addr;
                        r_saved_byte_en = i_byte_en;
                        // ライン境界にまたがった読み出しをマーク
                        r_need_two_line        = w_need_two_line;
                        r_firsttime_read_bytes = w_firsttime_read_bytes;
                    } else {
                        // 読み出さない場合は valid を下げる
                        for way: u32 in 0..DCACHE_CONF::associativity {
                            r_read_valid[way] = 0;
                        }
                    }
                }
                State::tag_cmp: {
                    // 状態の更新
                    if w_hit & !r_need_two_line {
                        r_state = State::idle;
                    } else if w_hit & r_need_two_line {
                        r_state = State::tag_cmp;
                    } else if !w_hit {
                        r_state = State::mem_req;
                    }

                    // 内部状態の更新
                    r_hit_way = w_hit_way;
                    for way: u32 in 0..DCACHE_CONF::associativity {
                        if r_read_valid[way] && r_read_tag[way] == w_saved_addr_tag {
                            // hit したラインから byte_en に従って切り出し
                            for idx: u32 in 0..DataWidthInByte {
                                if r_saved_byte_en[idx] && ((idx + w_saved_addr_line as 32) <: DCACHE_CONF::line_size) {
                                    r_hit_data[idx * 8+:8] = r_read_line[way][w_saved_addr_line as 32 + idx+:8];
                                } else if r_saved_byte_en[idx] {
                                    r_hit_data[idx * 8+:8] = 0;
                                }
                            }
                            break;
                        }
                    }
                    if r_need_two_line {
                        // 次のラインの先頭アドレス = 現在のラインの先頭アドレス + ラインサイズ
                        r_saved_addr           = DCACHE_CONF::get_line_addr(r_saved_addr) + DCACHE_CONF::line_size;
                        r_saved_byte_en        = r_saved_byte_en >> r_firsttime_read_bytes;
                        r_firsttime_read_bytes = DataWidthInByte as 16;
                        r_need_two_line        = 0;
                    }

                    // ミス時はメモリにリクエストを出す
                    if !w_hit {
                        if !r_saved_write_en {
                            // replace 位置は way=0 で仮決め
                            r_refill_way = 0;
                            // replace対象がdirtyならWB
                            if r_read_dirty[0] {
                                r_need_wb = 1;
                                // r_wb_line_addr = DCACHE_CONF::gen_addr(r_read_tag[0], DCACHE_CONF::get_index(r_saved_addr), 0);
                                r_wb_line = r_read_line[0];
                                mem_if.awid = 0;
                                mem_if.awvalid = 1;
                                mem_if.awaddr = DCACHE_CONF::gen_addr(r_read_tag[0], DCACHE_CONF::get_index(r_saved_addr), 0);
                                mem_if.awlen = DCACHE_CONF::line_size / AXI_CONF::DATA_WIDTH_BYTES;
                                mem_if.awburst = 2'z;

                                mem_if.wvalid = 1;
                                mem_if.wdata = r_read_line[0][0 +: 8*AXI_CONF::DATA_WIDTH_BYTES];
                                mem_if.wstrb = {1'b1 repeat AXI_CONF::DATA_WIDTH_BYTES};
                                mem_if.wlast = 0;
                                r_wb_burst_count = 1;
                            } else {
                                r_need_wb = 0;
                            }

                            // 
                            mem_if.arid = 0; // 仮
                            mem_if.arvalid = 1;
                            mem_if.araddr = DCACHE_CONF::get_line_addr(r_saved_addr);
                            mem_if.arlen = DCACHE_CONF::line_size / AXI_CONF::DATA_WIDTH_BYTES;
                            mem_if.arburst = 2'z;
                            mem_if.rready = 1;
                            r_mem_resp_count = 0;
                            r_mem_resp_line = 0;
                        }
                    }
                }
                State::mem_req: {
                    if !r_saved_write_en {
                        if mem_if.awaddr_ack() {
                            mem_if.awvalid = 0;
                        }
                        if mem_if.wdata_ack() {
                            r_wb_burst_count += 1;
                            mem_if.wdata = r_read_line[0][r_wb_burst_count*8*AXI_CONF::DATA_WIDTH_BYTES +: 8*AXI_CONF::DATA_WIDTH_BYTES];
                            if r_wb_burst_count + 1 == AXI_CONF::DATA_WIDTH_BYTES - 1 {
                                mem_if.wlast = 1;
                            }
                        }

                        if mem_if.araddr_ack() {
                            mem_if.arvalid = 0;
                        }
                        if mem_if.rdata_ack() {
                            r_mem_resp_count += 1;
                            r_mem_resp_line[r_mem_resp_count*8*AXI_CONF::DATA_WIDTH_BYTES +: 8*AXI_CONF::DATA_WIDTH_BYTES] = mem_if.rdata;
                            if mem_if.rlast {
                                mem_if.rready = 0;
                                // r_state = State::
                            }
                        }
                    }
                }
            }
        }
    }
}

module DCacheTagArray::< 
    PROC_CONF: proc_proto,
    DCACHE_CONF: dcache_proto,
>(
    i_clk: input clock,
    i_rst: input reset,

    i_ce: input logic,
    i_addr: input PROC_CONF::Addr,

    // ヒット用信号
    o_hit: output logic,
    o_hit_way: output DCACHE_CONF::WayIndex,

    // ミス用信号
    o_refill_way: output DCACHE_CONF::WayIndex,
    o_dirty: output logic,
    o_wb_line_addr: output PROC_CONF::Addr,

) {
    const WayIdxWidth:u32 = DCACHE_CONF::way_idx_width; // as DCACHE_CONF::way_idx_width は使えないので const で宣言

    var m_tag_array : DCACHE_CONF::Tag     [DCACHE_CONF::associativity, DCACHE_CONF::set_num];
    var m_valid     : logic               [DCACHE_CONF::associativity, DCACHE_CONF::set_num];
    var m_dirty     : logic               [DCACHE_CONF::associativity, DCACHE_CONF::set_num];

    let w_index: DCACHE_CONF::Index = DCACHE_CONF::get_index(i_addr);

    var r_read_tag: DCACHE_CONF::Tag [DCACHE_CONF::associativity]
    var r_read_valid: logic               [DCACHE_CONF::associativity];
    var r_read_dirty: logic               [DCACHE_CONF::associativity];
    var r_read_input_tag: DCACHE_CONF::Tag;
    var r_read_input_index: DCACHE_CONF::Index;
    var r_read_input_byte_en: logic<PROC_CONF::data_width / 8>;

    var w_cmp_hit: logic;
    var w_cmp_hit_way: DCACHE_CONF::WayIndex;
    let w_cmp_refill_way: DCACHE_CONF::WayIndex = 0; // 仮に way 0 に refill で固定

    always_ff {
        if_reset {
            for way: u32 in 0..DCACHE_CONF::associativity {
                r_read_tag[way] = 0;
                r_read_valid[way] = 0;
                r_read_dirty[way] = 0;
            }
            r_read_input_tag = 0;
            r_read_input_index = 0;
            r_read_input_byte_en = 0;
        } else if i_ce {
            for way: u32 in 0..DCACHE_CONF::associativity {
                r_read_tag[way] = m_tag_array[way][w_index];
                r_read_valid[way] = m_valid[way][w_index];
                r_read_dirty[way] = m_dirty[way][w_index];
            }
            r_read_input_tag = DCACHE_CONF::get_tag(i_addr);
            r_read_input_index = w_index;
            r_read_input_byte_en = i_byte_en;
        }
    }

    always_comb {
        w_cmp_hit = 0;
        for way: u32 in 0..DCACHE_CONF::associativity {
            if r_read_valid[way] && r_read_tag[way] == r_read_input_tag {
                w_cmp_hit = 1;
                w_cmp_hit_way = way as WayIdxWidth;
                break;
            }
        }

        o_hit = w_cmp_hit;
        o_hit_way = w_cmp_hit_way;
        o_refill_way = w_cmp_refill_way;
        o_dirty = r_read_dirty[w_cmp_hit_way];
        o_wb_line_addr = DCACHE_CONF::gen_addr(r_read_tag[w_cmp_refill_way], r_read_input_index, 0);
    }
}
